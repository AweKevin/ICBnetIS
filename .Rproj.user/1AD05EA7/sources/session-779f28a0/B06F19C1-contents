# WGCNA
library(WGCNA)

sel <- c("TCRsignalingPathway", "BCRSignalingPathway", "Antigen_Processing_and_Presentation")
FUN <- function(i) {
  genes <- fread("pathway.txt") %>%
    dplyr::filter(Category == i) %>%
    .$Symbol %>%
    unique()
}
gs <- lapply(sel, FUN)
names(gs) <- c("TCR", "BCR", "APP")

library(GSVA)
TCGA <- fread("SKCM_TCGA_surv_expr.txt", data.table = F)
exprSet <- TCGA %>%
  column_to_rownames("sample") %>%
  dplyr::select(-c(1:2)) %>%
  t() %>%
  as.data.frame()
dim(exprSet)
expr <- exprSet

TCGA_gsva <- as.data.frame(t(gsva(as.matrix(expr), gs, method = "ssgsea")))
df <- TCGA_gsva %>%
  as.data.frame() %>%
  rownames_to_column("sample")

WGCNA_matrix <- t(expr[order(apply(expr, 1, mad), decreasing = T)[1:2000], ])
sel <- colnames(WGCNA_matrix)
datExpr0 <- expr[sel, ] %>%
  t() %>%
  as.data.frame()
datExpr <- datExpr0

sampleNames <- rownames(datExpr)
datTraits <- datTraits[, c("sample", names(datTraits)[-1] %>% str_sort())]
names(datTraits)[1] <- "sample"
traitRows <- match(sampleNames, datTraits$sample)
rownames(datTraits) <- datTraits[traitRows, 1]
datTraits <- datTraits %>% dplyr::select(-1)
identical(rownames(datTraits), rownames(datExpr))

powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
sft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)

net <- blockwiseModules(
  datExpr,
  power = sft$powerEstimate,
  maxBlockSize = 6000,
  TOMType = "unsigned", minModuleSize = 30,
  reassignThreshold = 0, mergeCutHeight = 0.25,
  numericLabels = TRUE, pamRespectsDendro = FALSE,
  saveTOMs = F,
  verbose = 3
)
table(net$colors)

mergedColors <- labels2colors(net$colors)
table(mergedColors)

nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
moduleColors <- labels2colors(net$colors)
MEs0 <- moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs <- orderMEs(MEs0)

moduleTraitCor <- cor(MEs, datTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)

sizeGrWindow(10, 6)
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
  signif(moduleTraitPvalue, 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor)

modNames <- substring(names(MEs), 3)
geneModuleMembership <- as.data.frame(cor(datExpr, MEs, use = "p"))
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) <- paste("MM", modNames, sep = "")
names(MMPvalue) <- paste("p.MM", modNames, sep = "")

TOM <- TOMsimilarityFromExpr(datExpr, power = sft$powerEstimate)
probes <- colnames(datExpr)
inModule <- (moduleColors == module)
modProbes <- probes[inModule]
modTOM <- TOM[inModule, inModule]
dimnames(modTOM) <- list(modProbes, modProbes)

cyt <- exportNetworkToCytoscape(
  modTOM,
  edgeFile = paste("CytoscapeInput-edges-", paste(module, collapse = "-"), ".txt", sep = ""),
  nodeFile = paste("CytoscapeInput-nodes-", paste(module, collapse = "-"), ".txt", sep = ""),
  weighted = TRUE,
  threshold = 0.02,
  nodeNames = modProbes,
  nodeAttr = moduleColors[inModule]
)

library(circlize)
library(rtracklayer)
gtf_data <- import("gencode.v32.annotation.gtf")
gtf_data <- as.data.frame(gtf_data)
gtf <- gtf_data %>% dplyr::filter(gtf_data$source == "HAVANA" & type == "gene")
gtf <- gtf %>% dplyr::select(seqnames, start, end, gene_name)
names(gtf) <- c("chr", "start", "end", "gene")

pal <- c("#223D6C", "#D20A13", "#FFD121", "#088247", "#11AA4D", "#58CDD9", "#7A142C", "#5D90BA", "#029149", "#431A3D", "#91612D", "#6E568C", "#E0367A", "#D8D155", "#64495D", "#7CC767", ggsci::pal_lancet(alpha = 1)(8))

sel <- fread("WGCNA_turquoise.txt", header = F)
bed <- gtf %>%
  dplyr::filter(gene %in% sel$V1) %>%
  distinct() %>%
  dplyr::select(1:4)
bed <- bed %>% distinct(gene, .keep_all = T)

df <- geneModuleMembership
df <- df %>%
  rownames_to_column("gene") %>%
  dplyr::select(gene, MMturquoise)
sel <- fread("WGCNA_turquoise.txt", header = F)
df <- df %>% dplyr::filter(gene %in% sel$V1)
bed1 <- gtf %>%
  inner_join(df) %>%
  distinct(gene, .keep_all = T) %>%
  column_to_rownames("gene")

geneTraitSignificance <- as.data.frame(cor(datExpr, datTraits, use = "p"))
geneTraitSignificance <- geneTraitSignificance[moduleGenes, ]
df <- geneTraitSignificance
df <- df %>% rownames_to_column("gene")
sel <- fread("WGCNA_turquoise.txt", header = F)
df <- df %>% dplyr::filter(gene %in% sel$V1)
bed2 <- gtf %>%
  inner_join(df) %>%
  distinct(gene, .keep_all = T) %>%
  column_to_rownames("gene")
bed2_1 <- bed2 %>% dplyr::select(c(1:3, 4))
bed2_2 <- bed2 %>% dplyr::select(c(1:3, 5))
bed2_3 <- bed2 %>% dplyr::select(c(1:3, 6))


sel <- fread("WGCNA_turquoise.txt", header = F)
expr <- surv_expr %>%
  dplyr::select(-c("time", "status")) %>%
  column_to_rownames("sample") %>%
  t() %>%
  as.data.frame()
expr <- expr[sel$V1, ]
zscore <- function(x) {
  scale(x,
    center = apply(x, 2, min),
    scale = apply(x, 2, function(x) {
      max(x) - min(x)
    })
  )
}
expr <- zscore(t(expr))
df <- apply(expr, MARGIN = 2, mean) %>%
  as.data.frame() %>%
  rownames_to_column("gene")
names(df)[2] <- "value"
bed3 <- gtf %>%
  inner_join(df) %>%
  distinct(gene, .keep_all = T) %>%
  column_to_rownames("gene")
bed3$value <- scales::rescale(bed3$value, to = c(-1, 1))

df <- fread("CytoscapeInput-edges-turquoise.txt") %>% dplyr::select(1:3)
names(df)[1] <- "gene"
df <- gtf %>%
  inner_join(df) %>%
  distinct()
names(df)[1:4] <- str_c("fromNode_", names(df)[1:4])
names(df)[5] <- "gene"
df <- gtf %>%
  inner_join(df) %>%
  distinct()
names(df)[1:4] <- str_c("toNode_", names(df)[1:4])
bed4 <- df %>% distinct()
bed4$weight <- cut(bed4$weight, breaks = seq(min(bed4$weight), max(bed4$weight), 0.01))
levels(bed4$weight) <- c("#faf0ca", "#f4d35e", "#ee964b", "#f95738")

circos.clear()
circos.initializeWithIdeogram(species = "hg38", plotType = NULL)
circos.genomicLabels(bed[seq(1, 655, by = 2), ], labels.column = 4, side = "outside", cex = 0.36, line_lwd = 0.3)
circos.genomicLabels(bed[setdiff(1:655, seq(1, 655, by = 2)), ], labels.column = 4, side = "outside", cex = 0.36, line_lwd = 0.3)
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
  chr <- CELL_META$sector.index
  xlim <- CELL_META$xlim
  ylim <- CELL_META$ylim
  circos.rect(xlim[1], 0, xlim[2], 1, border = NA)
  circos.text(mean(xlim), mean(ylim), chr,
    cex = 0.7, col = "white",
    facing = "inside", niceFacing = TRUE
  )
}, track.height = 0.08, bg.border = NA, bg.col = ggplot2::alpha(pal, alpha = 1))
circos.genomicIdeogram()
circos.genomicTrack(bed1,
  panel.fun = function(region, value, ...) {
    circos.genomicPoints(region, value, pch = 16, cex = 0.3, col = ifelse(value[[1]] > 0, "#9e2a2b", "#335c67"))
  },
  track.height = 0.08, bg.col = ggplot2::alpha(pal, alpha = 0.6)
)
circos.genomicTrack(bed2_1,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value,
      ytop.column = 1, ybottom = 0,
      col = "black", ...
    )
    circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = "#00000040")
  }, track.height = 0.08, bg.col = ggplot2::alpha(pal, alpha = 0.6)
)
circos.genomicTrack(bed2_2,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value,
      ytop.column = 1, ybottom = 0,
      col = "black", ...
    )
    circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = "#00000040")
  }, track.height = 0.08, bg.col = ggplot2::alpha(pal, alpha = 0.6)
)
circos.genomicTrack(bed1,
  panel.fun = function(region, value, ...) {
    circos.genomicRect(region, value,
      ytop.column = 1, ybottom = 0,
      col = "black", ...
    )
    circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = "#00000040")
  }, track.height = 0.08, bg.col = ggplot2::alpha(pal, alpha = 0.6)
)
col_fun <- colorRamp2(
  c(-1, 0, 1),
  c("#5E4FA2", "#FFFFBF", "#9E0142")
)
circos.genomicHeatmap(bed3,
  col = col_fun, side = "inside", border = NA, heatmap_height = 0.035,
  connection_height = mm_h(4),
  line_col = rep(pal, table(bed$chr) %>% as.numeric() %>% .[-25])
)
circos.genomicLink(bed4[, 1:3], bed4[, 5:7], col = bed4$weight %>% as.character())

# RWR
library(Matrix)
(load("PPI_Network_STRING_HINT.RData"))
genes <- fread("pathway.txt") %>%
  dplyr::filter(Category == "TCRsignalingPathway") %>%
  .$Symbol
x <- RandomWalkRestart(Network, intersect(genes, rownames(Network)))
res <- x %>%
  as.data.frame() %>%
  set_colnames("rank") %>%
  rownames_to_column("gene") %>%
  arrange(desc(rank))
write.csv(res, "rank_TCR.csv", row.names = F)

genes <- fread("pathway.txt") %>%
  dplyr::filter(Category == "BCRSignalingPathway") %>%
  .$Symbol
x <- RandomWalkRestart(Network, intersect(genes, rownames(Network)))
res <- x %>%
  as.data.frame() %>%
  set_colnames("rank") %>%
  rownames_to_column("gene") %>%
  arrange(desc(rank))
write.csv(res, "rank_BCR.csv", row.names = F)

genes <- fread("pathway.txt") %>%
  dplyr::filter(Category == "Antigen_Processing_and_Presentation") %>%
  .$Symbol
x <- RandomWalkRestart(Network, intersect(genes, rownames(Network)))
res <- x %>%
  as.data.frame() %>%
  set_colnames("rank") %>%
  rownames_to_column("gene") %>%
  arrange(desc(rank))
write.csv(res, "rank_APP.csv", row.names = F)

library(clusterProfiler)
library(org.Hs.eg.db)
library(GseaVis)
l <- list.files(pattern = "^rank_.*.csv")

FUN <- function(file) {
  x <- read.csv(file)
  df <- x %>% as.data.frame()
  mRNA_si <- df
  head(mRNA_si)
  names(mRNA_si)[1] <- "HUGO"
  names(mRNA_si)[2] <- "Weight"
  mRNA_si$Weight <- as.numeric(as.character(mRNA_si$Weight))
  mRNA_si <- mRNA_si[order(mRNA_si$Weight, decreasing = T), ]
  mRNA_si <- mRNA_si %>% dplyr::filter(!is.na(Weight))
  si.id <- mRNA_si$Weight
  si.id <- length(si.id):1
  names(si.id) <- mRNA_si$HUGO
  return(si.id)
}
all_glist <- lapply(l, FUN)

hallmark$ENTREZID <- as.character(hallmark$ENTREZID)
ID <- bitr(hallmark$ENTREZID, fromType = "ENTREZID", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
hallmark <- hallmark %>%
  inner_join(ID) %>%
  dplyr::select(-ENTREZID)

TERM2GENE <- hallmark[, c("KEGGID", "SYMBOL")]
TERM2NAME <- hallmark[, c("KEGGID", "DESCRIPTION")]

lapply(1:3, function(x) {
  set.seed(2020)
  clustergsea <- GSEA(
    geneList = all_glist[[x]], TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME, verbose = F,
    minGSSize = 0, maxGSSize = 500, nPerm = 1000, pvalueCutoff = 1
  )
  clustergsea <- clustergsea[clustergsea$pvalue < 0.05, asis = T]
  return(clustergsea)
}) -> m_gsea_list

for (proj in c("_APP.csv", "_TCR.csv", "_BCR.csv")) {
  df <- read.csv(str_c("rank", proj))
  p_sel <- df %>%
    dplyr::slice(1:(0.1 * (nrow(df)))) %>%
    .$rank
  top1 <- df %>% dplyr::filter(rank >= p_sel)
  genes <- top1$gene %>% unique()
  expr <- expr[genes, ] %>% na.omit()
  df <- read.csv("easier.csv", row.names = 1)
  expr <- expr[, rownames(df)]
  FUN <- function(i) {
    exprSet <- rbind(df[, i], expr)
    rownames(exprSet)[1] <- i
    l <- lapply(2:nrow(exprSet), FUN = FUN_cor, exprSet = exprSet)
    tmp_res <- do.call(rbind, l)
    rownames(tmp_res) <- rownames(expr)
    tmp_res <- data.frame(term = i, tmp_res %>% rownames_to_column("gene"))
    return(tmp_res)
  }
  l <- lapply(names(df), FUN = FUN)
  l2 <- lapply(l, function(i) {
    i %>%
      dplyr::filter(cor > 0.6 & p < 0.05) %>%
      .$gene
  })
  genes <- purrr::reduce(l2, intersect)
  df2 <- data.frame(gene = genes)
  write.csv(df2, str_c("top_immune_genes", proj), row.names = F)
}

# ICBnetIS
library(survival)
library(funkyheatmap)

surv_expr %<>% dplyr::select(c("time", "status", genes))
## month
surv_expr$time <- surv_expr$time / 30

library(survival)
names(surv_expr) %<>% str_replace_all("-", "_")
FUN_surv <- function(i, surv_expr) {
  Sur <- Surv(surv_expr$time, surv_expr$status)
  cox <- coxph(Sur ~ surv_expr[, i], data = surv_expr)
  coxSummary <- summary(cox)
  gene <- names(surv_expr)[i]
  HR <- coxSummary$coefficients[, "exp(coef)"]
  lower <- coxSummary$conf.int[, 3]
  upper <- coxSummary$conf.int[, 4]
  PValue <- round(coxSummary$coefficients[, 5], 6)
  res <- data.frame(gene = gene, HR = HR, lower.95 = lower, upper.95 = upper, pvalue = PValue)
  return(res)
}
l <- pbapply::pblapply(3:ncol(surv_expr), FUN = FUN_surv, surv_expr = surv_expr)
Univar <- do.call(rbind, l)
Univar$gene <- Univar$gene %>% str_replace_all("_", "-")

head(Univar)
df <- Univar
names(df)[2] <- "HR"
names(df)[3] <- "lower"
names(df)[4] <- "upper"
names(df)[5] <- "pvalue"

df <- df %>% inner_join(imp2)
df$pvalue <- format(df$pvalue, digits = 3) %>% as.numeric()
df$pvalue <- ifelse(df$pvalue < 0.0001, "<0.0001", df$pvalue)
names(df)[1] <- "id"

df <- df %>% arrange(id)

column_info <- tribble(
  ~id, ~group, ~name, ~geom, ~palette, ~options,
  "id", NA, "gene", "text", NA, list(width = 6),
  "HR", "Unicox", "HR", "rect", "palette1", list(scale = FALSE),
  # "HR",   "Unicox",        "",           "text",        "palette1",  list(label = "HR"),
  "lower", "Unicox", "lower", "rect", "palette1", list(),
  "upper", "Unicox", "upper", "rect", "palette1", list(),
  "pvalue", "Unicox", "pvalue", "text", "palette1", list(width = 6),
  "imp", "RandomSurvivalForest", "importance", "bar", "palette2", list(width = 10)
)
column_groups <- tribble( # tribble_start
  ~Category, ~group, ~palette,
  "Unicox", "Unicox", "palette1",
  "RandomSurvivalForest", "RandomSurvivalForest", "palette2"
) # tribble_end

palettes <- tribble(
  ~palette, ~colours,
  "palette1", grDevices::colorRampPalette(RColorBrewer::brewer.pal(11, "RdYlBu") %>% rev())(50),
  "palette2", grDevices::colorRampPalette(RColorBrewer::brewer.pal(11, "RdYlBu") %>% rev())(50),
)

g <- funky_heatmap(df,
  column_info = column_info,
  column_groups = column_groups,
  palettes = palettes,
  expand = list(xmax = 4)
)

surv_expr <- fread("SKCM_TCGA_surv_expr.txt", data.table = F) %>% column_to_rownames("sample")
surv_expr %<>% dplyr::select(c("time", "status", genes))
## month
surv_expr$time <- surv_expr$time / 30

library(survival)
names(surv_expr) %<>% str_replace_all("-", "_")
FUN_surv <- function(i, surv_expr) {
  Sur <- Surv(surv_expr$time, surv_expr$status)
  cox <- coxph(Sur ~ surv_expr[, i], data = surv_expr)
  coxSummary <- summary(cox)
  gene <- names(surv_expr)[i]
  HR <- coxSummary$coefficients[, "exp(coef)"]
  lower <- coxSummary$conf.int[, 3]
  upper <- coxSummary$conf.int[, 4]
  PValue <- round(coxSummary$coefficients[, 5], 6)
  res <- data.frame(gene = gene, HR = HR, lower.95 = lower, upper.95 = upper, pvalue = PValue)
  return(res)
}
l <- pbapply::pblapply(3:ncol(surv_expr), FUN = FUN_surv, surv_expr = surv_expr)
Univar <- do.call(rbind, l)
Univar$gene <- Univar$gene %>% str_replace_all("_", "-")
Univar <- Univar %>% arrange(gene)

head(Univar)
df <- Univar
names(df)[2] <- "HR"
names(df)[3] <- "lower"
names(df)[4] <- "upper"
names(df)[5] <- "pvalue"
df$HR <- round(df$HR, 2)
df$lower <- round(df$lower, 2)
df$upper <- round(df$upper, 2)
df %<>% mutate(`HR (95%CI)` = str_c(HR, str_c("(", str_c(lower, upper, sep = "-"), ")")))
df$pvalue <- format(df$pvalue, digits = 3) %>% as.numeric()
df$pvalue <- ifelse(df$pvalue < 0.001, "<0.001", df$pvalue)

library(forestplot)
data <- df
head(data)
data1 <- data

hrtable <- rbind(
  data1
)

tabletext <- cbind(
  c("Gene", data1$gene),
  c("P Value", data1$pvalue),
  c("Hazard Ratio", data1$`HR (95%CI)`)
)
nrow(tabletext) + 1

forestplot(
  labeltext = tabletext,
  mean = c(NA, as.numeric(hrtable$HR)),
  lower = c(NA, as.numeric(hrtable$lower)),
  upper = c(NA, as.numeric(hrtable$upper)),
  # title="Hazard Ratio",
  graph.pos = 4,
  graphwidth = unit(.3, "npc"),
  col = fpColors(box = "#9e2a2b", lines = "#9e2a2b", zero = "black", summary = "grey"), # box颜色
  boxsize = 0.4,
  lwd.ci = 2, ci.vertices.height = 0,
  ci.vertices = T,
  zero = 1,
  lwd.zero = 2,
  xticks = seq(0.5, 1, 0.1),
  lwd.xaxis = 2,
  xlab = "Hazard Ratio",
  hrzl_lines = list(
    "1" = gpar(lwd = 2, col = "black"),
    "2" = gpar(lwd = 1, col = "grey50", lty = 2),
    "77" = gpar(lwd = 2, col = "black")
  ),
  lineheight = unit(0.6, "cm"),
  txt_gp = fpTxtGp(
    label = gpar(cex = 1.35),
    ticks = gpar(cex = 1.25),
    xlab = gpar(cex = 1.85),
    title = gpar(cex = 1.5)
  ),
  cex = 1,
  clip = c(0, 2),
  colgap = unit(0.3, "cm"),
  mar = unit(rep(1.25, times = 4), "cm"),
  new_page = F
)

library(GSVA)
exprSet <- surv_expr %>%
  dplyr::select(-c("time", "status")) %>%
  column_to_rownames("sample") %>%
  t() %>%
  as.data.frame()
(load("ICBnetIS.RData"))
tmp <- as.data.frame(t(gsva(as.matrix(exprSet), ICBnetIS, method = "ssgsea")))
surv_df <- cbind(surv_expr %>% dplyr::select(1:3), tmp)

library(survival)
library(survminer)
cutoff <- survminer::surv_cutpoint(surv_df, time = "time", event = "status", variables = "ICBnetIS", minprop = 0.1) %>% .$cutpoint
cutoff <- cutoff$cutpoint
surv_df$group <- ifelse(surv_df$ICBnetIS >= cutoff, "High", "Low")
surv_df$time <- surv_df$time / 30
sfit <- survfit(Surv(time, status) ~ group, data = surv_df)
diff <- survdiff(formula = Surv(time, status) ~ group, data = surv_df, rho = 0)
pval <- pchisq(diff$chisq, length(diff$n) - 1, lower.tail = FALSE)

# Function
library(clusterProfiler)
library(org.Hs.eg.db)
deg <- fread("DEG_ICBnetIS.txt")

KEGG <- read.csv("../HSA_KEGG.csv")
TERM2GENE <- KEGG[, c("KEGGID", "ENTREZID")]
TERM2NAME <- KEGG[, c("KEGGID", "DESCRIPTION")]

ID <- bitr(deg$symbol, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
yy <- enricher(ID$ENTREZID, TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME, pvalueCutoff = 1, qvalueCutoff = 1, minGSSize = 1)
head(yy)
yy1 <- setReadable(yy, OrgDb = org.Hs.eg.db, keyType = "ENTREZID")
head(yy1)
yy2 <- yy1[yy1$pvalue < 0.05, asis = T]

library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)
df <- fread("nrDEG_ICBnetIS.txt")
df <- df %>% dplyr::select(symbol, logFC)
mRNA_si <- df
head(mRNA_si)
names(mRNA_si)[1] <- "HUGO"
names(mRNA_si)[2] <- "Weight"
mRNA_si$Weight <- as.numeric(as.character(mRNA_si$Weight))
mRNA_si <- mRNA_si[order(mRNA_si$Weight, decreasing = T), ]
mRNA_si <- mRNA_si %>% dplyr::filter(!is.na(Weight))
si.id <- mRNA_si$Weight
names(si.id) <- mRNA_si$HUGO
head(si.id)

hallmark <- toTable(org.Hs.egGO) %>% dplyr::filter(Ontology == "BP")
names(hallmark)[1] <- "ENTREZID"
ID <- bitr(hallmark$ENTREZID, fromType = "ENTREZID", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
hallmark <- hallmark %>%
  inner_join(ID) %>%
  dplyr::select(-ENTREZID)

TERM2GENE <- hallmark[, c("go_id", "SYMBOL")]
TERM2NAME <- go2term(hallmark$go_id)
set.seed(2020)
clustergsea <- GSEA(
  geneList = si.id, TERM2GENE = TERM2GENE, TERM2NAME = TERM2NAME, verbose = F,
  minGSSize = 10, maxGSSize = 500, nPerm = 10000, pvalueCutoff = 1
)
clustergsea <- clustergsea[clustergsea$pvalue < 0.05, asis = T]

library(progeny)
pathways <- progeny(expr %>% as.matrix(),
  scale = TRUE,
  organism = "Human",
  top = 100, perm = 1
)

load("immunogram.RData")
library(GSVA)
gsym.expr <- exprSet
immunogram_gsva <- gsva(as.matrix(gsym.expr), Immunogram, method = "ssgsea")

load("cancer.cell.RData")
library(GSVA)
gsym.expr <- exprSet
cancer.cell_gsva <- gsva(as.matrix(gsym.expr), gs, method = "ssgsea")

# Immune
setwd("./IOBR-cell/")
l <- list.files()
l2 <- lapply(l, FUN_ann)
anno <- do.call(rbind, l2)
anno$Category[which(anno$Category == "estimate")] <- "ESTIMATE"
anno$Category[which(anno$Category == "ssGSEA")] <- "Pornpimol"
anno$Category[which(anno$Category == "timer")] <- "TIMER"
anno$Category[which(anno$Category == "mcp")] <- "MCPcounter"

FUN_cor <- function(i, temp) {
  res <- cor.test(temp[1, ] %>% as.numeric(), temp[i, ] %>% as.numeric())
  p <- res$p.value
  cor <- res$estimate
  df <- data.frame(p = p, cor = cor)
  rownames(df) <- rownames(temp)[i]
  return(df)
}

FUN_cor_df <- function(i) {
  temp <- read.csv(i) %>% column_to_rownames(names(.)[1])
  names(temp) <- sapply(names(temp), FUN_name) %>% as.character()
  temp <- temp %>%
    t() %>%
    as.data.frame()
  temp <- temp[, ICBnetIS$sample]
  temp <- rbind(ICBnetIS$ICBnetIS, temp)
  temp_l <- lapply(2:nrow(temp), FUN = FUN_cor, temp = temp)
  res <- do.call(rbind, temp_l) %>% rownames_to_column("cell")
  p.value <- res$p
  res$sig.label <- ifelse(p.value < 0.001, "****",
    ifelse(p.value < 0.005, "***",
      ifelse(p.value < 0.01, "**",
        ifelse(p.value < 0.05, "*", "")
      )
    )
  )
  res$lab <- str_c(res$cell, res$sig.label)
  expr_df <- temp[-1, ]
  exprSet <- expr_df
  n <- t(scale(t(exprSet)))
  n[n > 1] <- 1
  n[n < -1] <- -1
  exprSet <- n %>% as.data.frame()
  rownames(exprSet) <- res$lab
  return(exprSet)
}
l3 <- lapply(l, FUN_cor_df)

x <- fread("immunomodulator.txt") %>% as.data.frame()
names(x)[1] <- "gene"
names(x)[2] <- "Super category"
x <- x %>% arrange(`Super category`)

inter <- intersect(rownames(expr), x$gene)
x <- x %>% dplyr::filter(gene %in% inter)
inter <- x$gene
expr <- expr[inter, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample")
anno <- anno[inter, ]
anno <- anno %>%
  dplyr::select(-2) %>%
  rownames_to_column("gene")
FUN <- function(gene) {
  temp <- df[, c(gene, "cluster")]
  names(temp)[1] <- "gene"
  pv <- wilcox.test(gene ~ cluster, data = temp)$p.value
  return(data.frame(gene = gene, pv = pv))
}
l <- lapply(names(df)[-1], FUN)
res <- do.call(rbind, l)
p.value <- res$pv
res$sig.label <- ifelse(p.value < 0.001, "****",
  ifelse(p.value < 0.005, "***",
    ifelse(p.value < 0.01, "**",
      ifelse(p.value < 0.05, "*", "")
    )
  )
)

# Immunotherapy

generateInputFileForSubMap <- function(in_gct, gct_file, cls_file, sam_info, type_name = "type") {
  in_gct <- data.frame(
    GeneID = rownames(in_gct),
    description = "na",
    in_gct,
    stringsAsFactors = F,
    check.names = F
  )
  cat("#1.2\n", file = gct_file)
  cat(nrow(in_gct), "\t", ncol(in_gct) - 2, "\n", file = gct_file, append = T)
  cat(paste(colnames(in_gct), collapse = "\t"), "\n", file = gct_file, append = T)
  for (i in 1:nrow(in_gct)) cat(paste(in_gct[i, ], collapse = "\t"), "\n", file = gct_file, append = T)

  cat(nrow(sam_info), length(levels(factor(sam_info$rank))), 1, "\n", file = cls_file)
  cat("#", paste0(levels(factor(sam_info[, type_name])), collapse = " "), "\n", file = cls_file, sep = "", append = T)
  cat(as.numeric(factor(sam_info[, type_name])), file = cls_file, append = T)
}

skcm.immunotherapy.logNC <- read.table("skcm.immunotherapy.47samples.log2CountsNorm.txt", sep = "\t", row.names = 1, header = T, check.names = F, stringsAsFactors = F)
rownames(skcm.immunotherapy.logNC) <- toupper(rownames(skcm.immunotherapy.logNC))
skcm.immunotherapy.info <- read.table("skcm.immunotherapy.47sampleInfo.txt", sep = "\t", row.names = 1, header = T, check.names = F, stringsAsFactors = F)

skcm.immunotherapy.info <- skcm.immunotherapy.info[order(skcm.immunotherapy.info$label), ]
skcm.immunotherapy.info$rank <- rep(c(1, 2, 3, 4), times = as.character(table(skcm.immunotherapy.info$label)))

tmp <- TCGA %>%
  column_to_rownames("sample") %>%
  dplyr::select(-c(1:2)) %>%
  t() %>%
  as.data.frame()
tmp <- tmp[, rownames(ann)]
identical(names(tmp), rownames(ann))
GENELIST <- intersect(rownames(tmp), rownames(skcm.immunotherapy.logNC))

sam_info <- skcm.immunotherapy.info
in_gct <- skcm.immunotherapy.logNC[GENELIST, rownames(skcm.immunotherapy.info)]

gct_file <- "skcm.immunotherapy.for.SubMap.gct"
cls_file <- "skcm.immunotherapy.for.SubMap.cls"
generateInputFileForSubMap(in_gct = in_gct, gct_file = gct_file, cls_file = cls_file, sam_info = sam_info, type_name = "rank")

samples.C1 <- rownames(ann %>% dplyr::filter(ImmClust == "C1"))
samples.C2 <- rownames(ann %>% dplyr::filter(ImmClust == "C2"))

sam_info <- data.frame("ImmClust" = c(samples.C1, samples.C2), row.names = c(samples.C1, samples.C2))
sam_info$rank <- rep(c(1, 2), times = c(length(samples.C1), length(samples.C2))) #

gct_file <- "Immune2.for.SubMap.gct"
cls_file <- "Immune2.for.SubMap.cls"

in_gct <- tmp[GENELIST, rownames(sam_info)] # 产生和示例数据类似的形式，log2转化的标准化count值
generateInputFileForSubMap(in_gct = in_gct, gct_file = gct_file, cls_file = cls_file, sam_info = sam_info, type_name = "rank")


library(GSVA)
load("ICBnetIS.RData")
tmp <- gsva(as.matrix(exprSet), ICBnetIS, method = "ssgsea")
df <- tmp %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample")
df <- df %>% inner_join(pd)
df$Response <- factor(df$Response, levels = c("NR", "R"))
roc1 <- roc(df$Response, df$ICBnetIS,
  data = df, auc = TRUE,
  levels = c("NR", "R")
)

packages <- list(
  "tidyverse", "mboost", "survivalmodels", "partykit", "CoxBoost", "gbm", "obliqueRSF", "ranger",
  "randomForestSRC", "rpart", "survivalsvm", "xgboost", "glmnet", "plsRcox", "superpc", "snow", "snowfall"
)
lapply(packages, require, character.only = T)


# BlackBoost --------------------------------------------------------------

BlackBoost.mod <- function(train, minsplit = 10,
                           minbucket = 3, maxdepth = 5, mstop = 1000, Seed = 123456) {
  fit <- blackboost(Surv(time, status) ~ ., train,
                    family = CoxPH(),
                    control = boost_control(mstop = mstop),
                    tree_controls = partykit::ctree_control(
                      teststat = "quadratic",
                      testtype = "Bonferroni",
                      mincriterion = 0.95,
                      minsplit = minsplit,
                      minbucket = minbucket,
                      maxdepth = maxdepth,
                      saveinfo = FALSE
                    )
  )
  set.seed(Seed)
  cvm <- cvrisk(fit, papply = lapply, folds = cv(model.weights(fit), type = "kfold"))
  fit[mstop(cvm), return = F]
  return(fit)
}

BlackBoost.pred <- function(model, test) {
  score <- predict(model, newdata = test) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- BlackBoost.mod(train)
# pred_test <- BlackBoost.pred(mod, test)
# cindex(pred_test)


# GlmBoost ----------------------------------------------------------------

GlmBoost.mod <- function(train, mstop = 1000, Seed = 123456) {
  fit <- glmboost(Surv(time, status) ~ ., train,
                  family = CoxPH(),
                  control = boost_control(mstop = mstop),
                  center = F
  )
  set.seed(Seed)
  cvm <- cvrisk(fit, papply = lapply, folds = cv(model.weights(fit), type = "kfold"))
  fit[mstop(cvm), return = F]
  return(fit)
}

GlmBoost.pred <- function(model, test) {
  score <- predict(model, newdata = test) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- GlmBoost.mod(train)
# pred_test <- GlmBoost.pred(mod, test)
# cindex(pred_test)


# Akritas -----------------------------------------------------------------

Akritas.mod <- function(train) {
  fit <- akritas(Surv(time, status) ~ ., train,
                 lambda = 0.5, # Bandwidth parameter for uniform smoothing kernel in nearest neighbours estimation.
                 # The default value of 0.5 is arbitrary and should be chosen by the user.
                 # when lambda = 1, identical to Kaplan-Meier
                 reverse = F
  )
  return(fit)
}

Akritas.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "risk", distr6 = F) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- Akritas.mod(train)
# pred_test <- Akritas.pred(mod, test)
# cindex(pred_test)


# CForest -----------------------------------------------------------------

CForest.mod <- function(train, mstop = 1000, minsplit = 10,
                        minbucket = 3, maxdepth = 5, Seed = 123456) {
  set.seed(Seed)
  fit <- cforest(Surv(time, status) ~ ., train,
                 ntree = 1000,
                 control = partykit::ctree_control(
                   teststat = "quadratic",
                   testtype = "Bonferroni",
                   mincriterion = 0.95,
                   minsplit = minsplit,
                   minbucket = minbucket,
                   maxdepth = maxdepth,
                   saveinfo = FALSE
                 )
  )
  return(fit)
}

CForest.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "response", OOB = T) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- CForest.mod(train)
# pred_test <- CForest.pred(mod, test)
# cindex(pred_test)


# CTree -----------------------------------------------------------------

CTree.mod <- function(train, minsplit = 10, minbucket = 3, maxdepth = 5) {
  fit <- ctree(Surv(time, status) ~ ., train,
               control = partykit::ctree_control(
                 teststat = "quadratic",
                 testtype = "Bonferroni",
                 mincriterion = 0.95,
                 minsplit = minsplit,
                 minbucket = minbucket,
                 maxdepth = maxdepth,
                 saveinfo = FALSE
               )
  )
  return(fit)
}

CTree.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "response", OOB = T) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- CTree.mod(train)
# pred_test <- CTree.pred(mod, test)
# cindex(pred_test)


# CoxBoost --------------------------------------------------------------

CoxBoost.mod <- function(train, Seed = 123456) {
  time <- train$time
  status <- train$status
  x <- train %>%
    dplyr::select(-c(1:2)) %>%
    as.matrix()
  # determine penalty parameter
  set.seed(Seed)
  optim.CoxBoost <- optimCoxBoostPenalty(
    time = time, status = status, x = x,
    trace = T, start.penalty = 100
  )
  # Fit with obtained penalty parameter and optimal number of boosting
  # steps obtained by cross-validation
  mod.CoxBoost <- CoxBoost(
    time = time, status = status, x = x,
    stepno = optim.CoxBoost$cv.res$optimal.step,
    penalty = optim.CoxBoost$penalty
  )
  return(mod.CoxBoost)
}

CoxBoost.pred <- function(model, test) {
  coeff <- coef(model) %>%
    as.data.frame() %>%
    rownames_to_column("gene")
  names(coeff)[2] <- "coefficient"
  coeff %<>% dplyr::filter(coefficient != 0)
  tmp_expr <- test %>%
    dplyr::select(-c(1:2)) %>%
    as.data.frame()
  tmp_expr <- tmp_expr[, coeff$gene]
  score <- c()
  for (i in 1:nrow(tmp_expr)) {
    score[i] <- sum(coeff$coefficient * tmp_expr[i, ])
  }
  res.CoxBoost <- test %>% dplyr::select(time, status)
  res.CoxBoost$score <- score
  return(res.CoxBoost)
}

# mod <- CoxBoost.mod(train)
# pred_test <- CoxBoost.pred(mod, test)
# cindex(pred_test)


# StepwiseCox -----------------------------------------------------------------

StepwiseCox.mod <- function(train) {
  fit <- step(coxph(Surv(time, status) ~ ., train), direction = "backward", trace = F)
  return(fit)
}

StepwiseCox.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "risk") %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- StepwiseCox.mod(train)
# pred_test <- StepwiseCox.pred(mod, test)
# cindex(pred_test)


# CoxPH -----------------------------------------------------------------

CoxPH.mod <- function(train) {
  fit <- coxph(Surv(time, status) ~ ., train)
  return(fit)
}

CoxPH.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "risk") %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- CoxPH.mod(train)
# pred_test <- CoxPH.pred(mod, test)
# cindex(pred_test)


# GBM --------------------------------------------------------------

GBM.mod <- function(train, Seed = 123456, maxdepth = 5, minbucket = 3, train.fraction = 0.8) {
  set.seed(Seed)
  mod.GBM <- gbm(Surv(time, status) ~ .,
                 distribution = "coxph",
                 data = train,
                 n.trees = 1000,
                 interaction.depth = maxdepth,
                 n.minobsinnode = minbucket,
                 shrinkage = 0.05,
                 bag.fraction = 0.5,
                 train.fraction = train.fraction,
                 cv.folds = 10, n.cores = 6
  )
  # which.min(mod.GBM$cv.error)
  return(mod.GBM)
}

GBM.pred <- function(model, test) {
  best.iter <- suppressMessages(gbm.perf(model, plot.it = F, oobag.curve = F, method = "OOB"))
  score <- predict(model, newdata = test, n.trees = best.iter, type = "link") %>% as.numeric()
  res.GBM <- test %>% dplyr::select(time, status)
  res.GBM$score <- score
  return(res.GBM)
}

# mod <- GBM.mod(train)
# pred_test <- GBM.pred(mod, test)
# cindex(pred_test)


# SurvReg -----------------------------------------------------------------

SurvReg.mod <- function(train) {
  fit <- survreg(Surv(time, status) ~ ., train)
  return(fit)
}

SurvReg.pred <- function(model, test) {
  score <- predict(model, newdata = test, type = "lp") %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- SurvReg.mod(train)
# pred_test <- SurvReg.pred(mod, test)
# cindex(pred_test)


# ObliqueRSF -----------------------------------------------------------------

ObliqueRSF.mod <- function(train, Seed = 123456) {
  fit <- ORSF(train,
              alpha = 0.5, ntree = 1000, time = "time", status = "status",
              max_pval_to_split_node = 0.05, use.cv = T, verbose = F, random_seed = Seed
  )
  return(fit)
}

ObliqueRSF.pred <- function(model, test) {
  score <- rowMeans(predict(model, newdata = test, times = test$time)) %>% as.numeric()
  res <- test %>% dplyr::select(time, status)
  res$score <- score
  return(res)
}

# mod <- ObliqueRSF.mod(train)
# pred_test <- ObliqueRSF.pred(mod, test)
# cindex(pred_test)


# Ranger --------------------------------------------------------------

Ranger.mod <- function(train, Seed = 123456, splitrule = "logrank", # "logrank", "extratrees", "C" or "maxstat" with default "logrank".
                       minbucket = 3, maxdepth = 5) {
  set.seed(Seed)
  mod.Ranger <- ranger(Surv(time, status) ~ ., train,
                       num.trees = 1000, min.node.size = minbucket,
                       max.depth = maxdepth, seed = Seed, splitrule = splitrule
  )
  return(mod.Ranger)
}

Ranger.pred <- function(model, test) {
  score <- rowMeans(predict(model, num.trees = 1000, data = test)$chf) %>% as.numeric()
  res.Ranger <- test %>% dplyr::select(time, status)
  res.Ranger$score <- score
  return(res.Ranger)
}

# mod <- Ranger.mod(train)
# pred_test <- Ranger.pred(mod, test)
# cindex(pred_test)


# RSF --------------------------------------------------------------


RSF.mod <- function(train) {
  mod.RSF <- rfsrc(Surv(time, status) ~ .,
                   data = train,
                   ntree = 1000,
                   splitrule = "logrank",
                   importance = T,
                   proximity = T,
                   forest = T,
                   seed = 123456
  )
  # mod.RSF <- rfsrc(Surv(time, status) ~ .,
  #                  data = train,
  #                  ntree = which.min(mod.RSF$err.rate),
  #                  splitrule = "logrank",
  #                  importance = T,
  #                  proximity = T,
  #                  forest = T,
  #                  seed = 123456
  # )
  return(mod.RSF)
}

RSF.pred <- function(model, test) {
  pred.RSF <- predict(
    object = model,
    newdata = test,
    proximity = T
  )
  score <- pred.RSF$predicted
  res.RSF <- test %>% dplyr::select(time, status)
  res.RSF$score <- score
  return(res.RSF)
}

# mod <- RSF.mod(train)
# pred_test <- RSF.pred(mod, test)
# cindex(pred_test)


# Rpart --------------------------------------------------------------

Rpart.mod <- function(train, minbucket = 3, maxdepth = 5, minsplit = 10) {
  mod.Rpart <- rpart(Surv(time, status) ~ ., train,
                     method = "exp",
                     control = rpart.control(
                       minsplit = minsplit, minbucket = minbucket,
                       maxdepth = maxdepth
                     )
  )
  return(mod.Rpart)
}

Rpart.pred <- function(model, test) {
  score <- predict(model, newdata = test) %>% as.numeric()
  res.Rpart <- test %>% dplyr::select(time, status)
  res.Rpart$score <- score
  return(res.Rpart)
}

# mod <- Rpart.mod(train)
# pred_test <- Rpart.pred(mod, test)
# cindex(pred_test)


# SurvivalSVM --------------------------------------------------------------

SurvivalSVM.mod <- function(train) {
  mod.survivalSVM <- survivalsvm(Surv(time, status) ~ .,
                                 data = train,
                                 gamma.mu = 0.5,
                                 type = "regression",
                                 opt.meth = "ipop", kernel = "add_kernel"
  )
  return(mod.survivalSVM)
}

SurvivalSVM.pred <- function(model, test) {
  pred.survivalSVM <- predict(
    object = model,
    newdata = test
  )
  score <- pred.survivalSVM$predicted %>% as.numeric()
  res.survivalSVM <- test %>% dplyr::select(time, status)
  res.survivalSVM$score <- score
  return(res.survivalSVM)
}

# mod <- SurvivalSVM.mod(train)
# pred_test <- SurvivalSVM.pred(mod, test)
# cindex(pred_test)


# Ridge --------------------------------------------------------------

Ridge.mod <- function(train, Seed = 123456) {
  x2 <- as.matrix(train %>% dplyr::select(-c(1:2)))
  y2 <- data.matrix(Surv(train$time, as.factor(train$status)))
  set.seed(Seed)
  cv.fit <- cv.glmnet(x2, y2,
                      nfolds = 10,
                      family = "cox", # cox
                      grouped = FALSE,
                      alpha = 0,
                      type.measure = "mse"
  )
  # plot(cv.fit)
  fit <- glmnet(x2, y2, family = "cox", alpha = 0)
  # plot(fit)
  mod.Ridge <- list(cv.fit, fit)
  return(mod.Ridge)
}

Ridge.pred <- function(model, test) {
  cv.fit <- model[[1]]
  fit <- model[[2]]
  coeff <- coef(fit, s = cv.fit$lambda.min)
  index <- which(as.numeric(coeff) != 0)
  coefficient <- coeff[which(as.numeric(coeff) != 0)]
  gene <- rownames(coeff)[index]
  coeff <- data.frame(gene, coefficient)
  tmp_expr <- test %>%
    dplyr::select(-c(1:2)) %>%
    as.data.frame()
  tmp_expr <- tmp_expr[, coeff$gene]
  score <- c()
  for (i in 1:nrow(tmp_expr)) {
    score[i] <- sum(coeff$coefficient * tmp_expr[i, ])
  }
  res.Ridge <- test %>% dplyr::select(time, status)
  res.Ridge$score <- score
  return(res.Ridge)
}

# mod <- Ridge.mod(train)
# pred_test <- Ridge.pred(mod, test)
# cindex(pred_test)


# Enet --------------------------------------------------------------

Enet.mod <- function(train, Seed = 123456, alpha = 0.5) {
  x2 <- as.matrix(train %>% dplyr::select(-c(1:2)))
  y2 <- data.matrix(Surv(train$time, as.factor(train$status)))
  set.seed(Seed)
  cv.fit <- cv.glmnet(x2, y2,
                      nfolds = 10,
                      family = "cox", # cox
                      grouped = FALSE,
                      alpha = alpha,
                      type.measure = "mse"
  )
  # plot(cv.fit)
  fit <- glmnet(x2, y2, family = "cox", alpha = alpha)
  # plot(fit)
  mod.Enet <- list(cv.fit, fit)
  return(mod.Enet)
}

Enet.pred <- function(model, test) {
  cv.fit <- model[[1]]
  fit <- model[[2]]
  coeff <- coef(fit, s = cv.fit$lambda.min)
  index <- which(as.numeric(coeff) != 0)
  coefficient <- coeff[which(as.numeric(coeff) != 0)]
  gene <- rownames(coeff)[index]
  coeff <- data.frame(gene, coefficient)
  tmp_expr <- test %>%
    dplyr::select(-c(1:2)) %>%
    as.data.frame()
  tmp_expr <- tmp_expr[, coeff$gene]
  score <- c()
  for (i in 1:nrow(tmp_expr)) {
    score[i] <- sum(coeff$coefficient * tmp_expr[i, ])
  }
  res.Enet <- test %>% dplyr::select(time, status)
  res.Enet$score <- score
  return(res.Enet)
}

# mod <- Enet.mod(train)
# pred_test <- Enet.pred(mod, test)
# cindex(pred_test)


# Lasso --------------------------------------------------------------

Lasso.mod <- function(train, Seed = 123456) {
  x2 <- as.matrix(train %>% dplyr::select(-c(1:2)))
  y2 <- data.matrix(Surv(train$time, as.factor(train$status)))
  set.seed(Seed)
  cv.fit <- cv.glmnet(x2, y2,
                      # nfolds = nrow(x2),
                      nfolds = 10,
                      family = "cox", # cox
                      grouped = FALSE,
                      alpha = 1,
                      type.measure = "mse"
  )
  # plot(cv.fit)
  fit <- glmnet(x2, y2, family = "cox", alpha = 1)
  # plot(fit)
  mod.Lasso <- list(cv.fit, fit)
  return(mod.Lasso)
}

Lasso.pred <- function(model, test) {
  cv.fit <- model[[1]]
  fit <- model[[2]]
  coeff <- coef(fit, s = cv.fit$lambda.min)
  index <- which(as.numeric(coeff) != 0)
  coefficient <- coeff[which(as.numeric(coeff) != 0)]
  gene <- rownames(coeff)[index]
  coeff <- data.frame(gene, coefficient)
  tmp_expr <- test %>%
    dplyr::select(-c(1:2)) %>%
    as.data.frame()
  tmp_expr <- tmp_expr[, coeff$gene]
  score <- c()
  for (i in 1:nrow(tmp_expr)) {
    score[i] <- sum(coeff$coefficient * tmp_expr[i, ])
  }
  res.Lasso <- test %>% dplyr::select(time, status)
  res.Lasso$score <- score
  return(res.Lasso)
}

# mod <- Lasso.mod(train)
# pred_test <- Lasso.pred(mod, test)
# cindex(pred_test)


# PlsRcox --------------------------------------------------------------

PlsRcox.mod <- function(train, Seed = 123456) {
  time <- train$time
  status <- train$status
  x <- train %>%
    dplyr::select(-c(1:2)) %>%
    as.matrix()
  gene.names <- colnames(x)
  set.seed(Seed)
  plsRcox.cv <- cv.plsRcox(data = list(x = x, time = time, status = status), nfold = 10, nt = 10)
  nt <- which.max(plsRcox.cv$cv.error5[-1])
  mod.plsRcox <- plsRcox(x, time = time, event = status, nt = nt, sparse = F)
  mod.plsRcox <- list(mod.plsRcox, gene.names)
  return(mod.plsRcox)
}

PlsRcox.pred <- function(model, test) {
  model <- model[[1]]
  gene.names <- model[[2]]
  coeff <- model$Coeffs %>%
    as.data.frame() %>%
    rownames_to_column("gene")
  coeff$gene <- gene.names
  names(coeff)[2] <- "coefficient"
  tmp_expr <- test %>%
    dplyr::select(-c(1:2)) %>%
    as.data.frame()
  tmp_expr <- tmp_expr[, coeff$gene]
  score <- c()
  for (i in 1:nrow(tmp_expr)) {
    score[i] <- sum(coeff$coefficient * tmp_expr[i, ])
  }
  res.plsRcox <- test %>% dplyr::select(time, status)
  res.plsRcox$score <- score
  return(res.plsRcox)
}

# mod <- PlsRcox.mod(train)
# pred_test <- PlsRcox.pred(mod, test)
# cindex(pred_test)


# SuperPC --------------------------------------------------------------

SuperPC.mod <- function(train, Seed = 123456) {
  x2 <- train %>%
    dplyr::select(-c(1:2)) %>%
    t()
  y2 <- train$time
  censoring.status <- train$status
  featurenames <- rownames(x2)
  data.train <- list(
    x = x2,
    y = y2,
    censoring.status = censoring.status,
    featurenames = featurenames
  )
  obj.SuperPC <- superpc.train(data.train, type = "survival")
  set.seed(Seed)
  cv.SuperPC <- superpc.cv(obj.SuperPC,
                           data.train,
                           n.components = 1,
                           n.threshold = 20,
                           min.features = 0,
                           max.features = length(featurenames),
                           n.fold = 10
  )
  sel <- cv.SuperPC$scor %>% which.max()
  threshold <- cv.SuperPC$thresholds[sel]
  mod.SuperPC <- list(obj.SuperPC, threshold, data.train)
  return(mod.SuperPC)
}

SuperPC.pred <- function(model, test) {
  obj.SuperPC <- model[[1]]
  threshold <- model[[2]]
  data.train <- model[[3]]
  x2 <- test %>%
    dplyr::select(-c(1:2)) %>%
    t()
  y2 <- test$time
  censoring.status <- test$status
  featurenames <- rownames(x2)
  data.test <- list(
    x = x2,
    y = y2,
    censoring.status = censoring.status,
    featurenames = featurenames
  )
  fit.cts <- superpc.predict(obj.SuperPC, data = data.train, newdata = data.test, threshold = threshold, n.components = 1, prediction.type = "continuous")
  score <- fit.cts$v.pred %>% as.numeric()
  res.SuperPC <- test %>% dplyr::select(time, status)
  res.SuperPC$score <- score
  return(res.SuperPC)
}

# mod <- SuperPC.mod(train)
# pred_test <- SuperPC.pred(mod, test)
# cindex(pred_test)


# XGBoost --------------------------------------------------------------

XGBoost.mod <- function(train, Seed = 123456, maxdepth = 3) {
  dat.mat <- as.matrix(train)
  dtrain <- list(
    data = dat.mat[, 3:ncol(train)],
    label = dat.mat[, "time"] * (-(-1)^(as.numeric(dat.mat[, "status"])))
  )
  Dtrain <- xgb.DMatrix(dtrain$data, label = dtrain$label)
  param <- list(
    max_depth = maxdepth,
    eta = 0.01,
    gamma = 0,
    subsample = 0.8,
    colsample_bytree = 0.8,
    min_child_weight = 2,
    lambda = 1,
    alpha = 0
  )
  set.seed(Seed)
  cvfit <- xgb.cv(
    data = Dtrain, params = param, nthread = 8,
    nfold = 10, nrounds = 1000, verbose = F, early_stop_round = 30, maximize = F
  )
  set.seed(Seed)
  fit <- xgboost(
    data = Dtrain, params = param, nthread = 8, verbose = F,
    nrounds = which.min(cvfit$evaluation_log$test_rmse_mean)
  )
  return(fit)
}

XGBoost.pred <- function(model, test) {
  x.mat <- as.matrix(test)
  dd <- list(
    data = x.mat[, 3:ncol(test)],
    label = x.mat[, "time"] * (-(-1)^(as.numeric(x.mat[, "status"])))
  )
  Dtrain <- xgb.DMatrix(dd$data, label = dd$label)
  score <- predict(model, Dtrain) %>% as.numeric()
  res.XGBoost <- test %>% dplyr::select(time, status)
  res.XGBoost$score <- score
  return(res.XGBoost)
}

# mod <- XGBoost.mod(train)
# pred_test <- XGBoost.pred(mod, test)
# cindex(pred_test)


